<!DOCTYPE html>
<html>

	<head>
		<title>tri-d-chess</title>
		<style>
			body {
				background-color: #000;
				color: #000;
				margin: 0;
			}

			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
	</head>

	<body>
		<script src="js/three.js/three.min.js"></script>
		<script src="js/three.js/controls/OrbitControls.js"></script>
		<script src="js/three.js/controls/DragControls.js"></script>

		<script src="js/tridchess.js"></script>

		<script>

			// Init
			var scene = new THREE.Scene();

			var width = window.innerWidth;
			var height = window.innerHeight;
			var camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);
			camera.position.set(-10, 7, -10);

			var renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(width, height);
			document.body.appendChild(renderer.domElement);

			var objects = [];

			var axesHelper = new THREE.AxesHelper(10);
			scene.add(axesHelper);

			// Controls
			var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
			orbitControls.minDistance = 2;
			orbitControls.maxDistance = 100;
			orbitControls.enablePan = false;
			orbitControls.zoomSpeed = 1.0;
			orbitControls.rotateSpeed = 1.0;
			orbitControls.minPolarAngle = 0;
			orbitControls.maxPolarAngle = Math.PI;

			var dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
			dragControls.addEventListener('dragstart', function() {
				orbitControls.enabled = false;
			});
			dragControls.addEventListener('dragend', function() {
				orbitControls.enabled = true;
			});
			
			
			// World
			//var geometry = new THREE.BoxGeometry(1, 1, 1);
			//var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
			//var cube = new THREE.Mesh(geometry, material);
			//scene.add(cube);
			//objects.push(cube);

			// Tridchess
			var tridchess = new Tridchess();
			/* Build board */

			var clickable = [];
			
			// Board
			var board = new THREE.Group();
			var boardArr = tridchess.getBoard();

			// Square Indicators
			var squareInd = new THREE.Group();
			var indGeo = new THREE.PlaneGeometry();
			var indMat= new THREE.MeshBasicMaterial( {color: 0xfafcb8,
													  side: THREE.DoubleSide} );

			// Towers
			var towers = new THREE.Group();
			var towerPos = [ new THREE.Vector3(0.5, 0, 0.5),
							 new THREE.Vector3(4.5, 0, 0.5),
							 new THREE.Vector3(0.5, 0, 4.5),
							 new THREE.Vector3(4.5, 0, 4.5),
							 new THREE.Vector3(0.5, 4, 2.5),
							 new THREE.Vector3(4.5, 4, 2.5),
							 new THREE.Vector3(0.5, 4, 6.5),
							 new THREE.Vector3(4.5, 4, 6.5),
							 new THREE.Vector3(0.5, 8, 4.5),
							 new THREE.Vector3(4.5, 8, 4.5),
							 new THREE.Vector3(0.5, 8, 8.5),
							 new THREE.Vector3(4.5, 8, 8.5) ];

			var towerArr = tridchess.getTowers();

			var towGeo = new THREE.BoxGeometry(0.25, 2, 0.25);
			towGeo.translate(0, 1, 0); // Set origin at bottom
			var towMat = new THREE.MeshBasicMaterial( {color: 0xff000} );

			

			// Pieces
			var pieces = new THREE.Group();
			var pieHeight = 1.25;

			var pieGeo = new THREE.BoxGeometry(0.5, pieHeight, 0.5);
			pieGeo.translate(0, pieHeight / 2, 0); // Set Origin at bottom
			var pieMat = new THREE.MeshBasicMaterial( {color: 0xaabce2} );

			var pieModels = [];
			for(var i=0; i<6; i++) {
				pieModels.push(new THREE.Mesh(pieGeo, pieMat));
			}

			// Traverse board
			for (var iFile = 0; iFile < boardArr.length; iFile++) {

				for (var iColumn = 0; iColumn < boardArr[iFile].length; iColumn++) {

					for (var iLevel = 0; iLevel < boardArr[iFile][iColumn].length; iLevel++) {
						
						var square = boardArr[iFile][iColumn][iLevel]; 

						if (square !== null) {

							// Add indicators
							var ind = new THREE.Mesh(indGeo, indMat);

							ind.position.x = -iFile;
							ind.position.z = iColumn;
							ind.position.y = iLevel * 2 + 0.01;

							ind.rotateX(-Math.PI / 2);

							squareInd.add(ind);

							// Add pieces
							// 1:Pawn, 2:Knight, 3:Bishop, 4:Rook, 5:Queen, 6:King
							if (square !== 0) {

								//var piece = pieModels[square-1];
								var piece = new THREE.Mesh(pieGeo, pieMat);
								
								piece.position.x = -iFile;
								piece.position.z = iColumn;
								piece.position.y = iLevel * 2;

								//piece.position.y += pieHeight / 2;
								
								pieces.add(piece);

								clickable.push(piece);

							}
						}
					} 
				} 
			} 

			// Add Towers
			for (var iTower = 0; iTower < towerArr.length; iTower++) {

				var tower = new THREE.Mesh(towGeo, towMat);
				
				console.log("iTower: " + iTower + ", tower: " + towerArr[iTower]);
				tower.position.x = -towerPos[ towerArr[iTower] - 1].x;
				tower.position.y = towerPos[ towerArr[iTower]  - 1].y;
				tower.position.z = towerPos[ towerArr[iTower]  - 1].z;

				towers.add(tower);

			}

			board.add(squareInd);
			board.add(pieces);
			board.add(towers);

			// Center board on origin
			board.position.x += 2.5;
			board.position.y -= 4;
			board.position.z -= 4.5;

			scene.add(board);

			function onDocumentMouseMove(event) { 
				event.preventDefault();
				pieces.visible=false; 
			}

			// Window Resizing
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			window.addEventListener('resize', onWindowResize, false);

			// Animation loop
			function animate() {
				requestAnimationFrame(animate);
				//cube.rotation.x += 0.01;
				//cube.rotation.y += 0.01;
				renderer.render(scene, camera);
			}

			animate();

		</script>
	</body>

<html>
