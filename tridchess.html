<!DOCTYPE html>
<html>

	<head>
		<title>tri-d-chess</title>
		<style>
			body {
				background-color: #000;
				color: #000;
				margin: 0;
			}

			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
	</head>

	<body>
		<script src="js/three.js/three.min.js"></script>
		<script src="js/three.js/controls/OrbitControls.js"></script>
		<script src="js/three.js/controls/DragControls.js"></script>

		<script src="js/tridchess.js"></script>

		<script>

			// Init
			var scene = new THREE.Scene();

			var width = window.innerWidth;
			var height = window.innerHeight;
			var camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);
			camera.position.set(-10, 7, -10);

			var renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(width, height);
			document.body.appendChild(renderer.domElement);

			var objects = [];

			var axesHelper = new THREE.AxesHelper(10);
			scene.add(axesHelper);

			// Controls
			var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
			orbitControls.minDistance = 2;
			orbitControls.maxDistance = 100;
			orbitControls.enablePan = false;
			orbitControls.zoomSpeed = 1.0;
			orbitControls.rotateSpeed = 1.0;
			orbitControls.minPolarAngle = 0;
			orbitControls.maxPolarAngle = Math.PI;

			var dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
			dragControls.addEventListener('dragstart', function() {
				orbitControls.enabled = false;
			});
			dragControls.addEventListener('dragend', function() {
				orbitControls.enabled = true;
			});
			
			
			// World
			//var geometry = new THREE.BoxGeometry(1, 1, 1);
			//var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
			//var cube = new THREE.Mesh(geometry, material);
			//scene.add(cube);
			//objects.push(cube);

			/* Build board */

			var clickable = [];
			
			// Board
			var board = new THREE.Group();
			var boardArr = Tridchess.getBoard();

			// Square Indicators
			var squareInd = new THREE.Group();
			var indGeo = new THREE.PlaneGeometry();
			var indMat= new THREE.MeshBasicMaterial( {color: 0xfafcb8/*,
													  side: THREE.DoubleSide*/} );

			// Towers
			var towers = new THREE.Group();
			var towGeo = new THREE.BoxGeometry(0.25, 2, 0.25);
			var towMat = new THREE.MeshBasicMaterial( {color: 0xff000} );

			// Pieces
			var pieces = new THREE.Group();
			var pieHeight = 1.25;

			var pieGeo = new THREE.BoxGeometry(0.5, pieHeight, 0.5);
			pieGeo.translate(0, pieHeight / 2, 0); // Set Origin at bottom
			var pieMat = new THREE.MeshBasicMaterial( {color: 0xaabce2} );

			var pieModels = [];
			for(var i=0; i<6; i++) {
				pieModels.push(new THREE.Mesh(pieGeo, pieMat));
			}

			// Traverse board
			for (var iFile = 0; iFile < boardArr.length; iFile++) {

				for (var iColumn = 0; iColumn < boardArr[iFile].length; iColumn++) {

					for (var iLevel = 0; iLevel < boardArr[iFile][iColumn].length; iLevel++) {
						
						var square = boardArr[iFile][iColumn][iLevel]; 

						if (square !== null) {

							// Add indicators
							var ind = new THREE.Mesh(indGeo, indMat);

							ind.position.x = -iFile;
							ind.position.z = iColumn;
							ind.position.y = iLevel * 2;

							ind.rotateX(-Math.PI / 2);

							squareInd.add(ind);

							// Add pieces
							// 1:Pawn, 2:Knight, 3:Bishop, 4:Rook, 5:Queen, 6:King
							if (square !== 0) {

								//var piece = pieModels[square-1];
								var piece = new THREE.Mesh(pieGeo, pieMat);
								
								piece.position.x = -iFile;
								piece.position.z = iColumn;
								piece.position.y = iLevel * 2;

								//piece.position.y += pieHeight / 2;
								
								pieces.add(piece);

								clickable.push(piece);

							}
						}
					} 
				} 
			} 

			// Add Towers
			var towerPos;
			var tower = new THREE.Mesh(towGeo, towMat);

			board.add(squareInd);
			board.add(pieces);
			board.add(towers);

			// Center board on origin
			board.position.x += 2.5;
			board.position.y -= 4;
			board.position.z -= 4.5;

			scene.add(board);

			function onDocumentMouseMove(event) { 
				event.preventDefault();
				pieces.visible=false; 
			}

			// Window Resizing
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			window.addEventListener('resize', onWindowResize, false);

			// Animation loop
			function animate() {
				requestAnimationFrame(animate);
				//cube.rotation.x += 0.01;
				//cube.rotation.y += 0.01;
				renderer.render(scene, camera);
			}

			animate();

		</script>
	</body>

<html>
