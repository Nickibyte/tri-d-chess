<!DOCTYPE html>
<html>

	<head>
		<title>tri-d-chess</title>
		<style>
			body {
				background-color: #000;
				color: #000;
				margin: 0;
			}

			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
	</head>

	<body>
		<script src="js/three.js/three.min.js"></script>
		<script src="js/three.js/controls/OrbitControls.js"></script>
		<script src="js/three.js/controls/DragControls.js"></script>

		<script src="js/tridchess.js"></script>

		<script>

			// Init
			var scene = new THREE.Scene();

			var width = window.innerWidth;
			var height = window.innerHeight;
			var camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);
			camera.position.set(-10, 7, 10);
			var mouseMain = new THREE.Vector2();

			var renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(width, height);
			document.body.appendChild(renderer.domElement);


			var objects = [];

			var axesHelper = new THREE.AxesHelper(10);
			scene.add(axesHelper);

			// Controls
			var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
			orbitControls.minDistance = 2;
			orbitControls.maxDistance = 100;
			orbitControls.enablePan = false;
			orbitControls.zoomSpeed = 1.0;
			orbitControls.rotateSpeed = 1.0;
			orbitControls.minPolarAngle = 0;
			orbitControls.maxPolarAngle = Math.PI;

			//var dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
			//dragControls.addEventListener('dragstart', function() {
			//	orbitControls.enabled = false;
			//});
			//dragControls.addEventListener('dragend', function() {
			//	orbitControls.enabled = true;
			//});

			var raycaster = new THREE.Raycaster();
			
			// ----------------------------------------------------------------
			// ----------------------------------------------------------------
			// Setup
			// ----------------------------------------------------------------
			// ----------------------------------------------------------------
			
			function posToVector3(pos) {

				return new THREE.Vector3(pos.r, pos.l * 2, pos.f );

			}
			
			// Tridchess
			var tridchess = new Tridchess();

			var selectable = [];
			
			
			// ----------------------------------------------------------------
			// Square Indicators
			// ----------------------------------------------------------------

			var indGeo = new THREE.PlaneGeometry();
			indGeo.translate(0, 0, 0.01); // Set origin below square
			var indMat= new THREE.MeshBasicMaterial( {color: 0xfafcb8,
													  side: THREE.DoubleSide} );


			// ----------------------------------------------------------------
			// Main Board
			// ----------------------------------------------------------------

			var board = new THREE.Group();

			// TODO: Build board


			var boardArr = tridchess.getBoard();

			// ----------------------------------------------------------------
			// Towers
			// ----------------------------------------------------------------

			var towGeo = new THREE.BoxGeometry(0.25, 2, 0.25);
			towGeo.translate(0, -1, 0); // Set origin at top
			var towMat = new THREE.MeshBasicMaterial( {color: 0xff000} );

			// Add Towers
			var towers = new THREE.Group();

			for (var tower = 0; tower < 12; tower++) { 

				var towGroup = new THREE.Group();
				towGroup.name = "T" + (tower+1);

				var vec;

				for (var square = 0; square < 4; square++) {

					// Get position
					var pos = tridchess.towerSquares[tower][square];
					vec = posToVector3(pos); 	
					
					var squGroup = new THREE.Group();
					squGroup.name = 'abcdef'.charAt(pos.f) + pos.r + "_" + pos.l;
					squGroup.userData = pos;

					// Place square indicator
					var ind = new THREE.Mesh(indGeo, indMat);

					ind.position.x = vec.x;
					ind.position.y = vec.y;
					ind.position.z = vec.z;

					ind.rotateX(-Math.PI / 2); // Rotate upright

					squGroup.add(ind);
					towGroup.add(squGroup);

				}

				// Add offset from square to center of tower
				vec = vec.add( new THREE.Vector3(-0.5, 0, -0.5) ); 

				// Place tower
				var tow = new THREE.Mesh(towGeo, towMat);

				tow.position.x = vec.x;
				tow.position.y = vec.y;
				tow.position.z = vec.z;

				towGroup.add(tow);

				towers.add(towGroup);

				selectable.push(towGroup); // DEBUG
			}


			var towerArr = tridchess.getTowers();


			// ----------------------------------------------------------------
			// Pieces
			// ----------------------------------------------------------------

			var pieces = new THREE.Group();
			var pieHeight = 1.25;

			var pieGeo = new THREE.BoxGeometry(0.5, pieHeight, 0.5);
			pieGeo.translate(0, pieHeight / 2, 0); // Set Origin at bottom
			var pieMat = new THREE.MeshBasicMaterial( {color: 0xaabce2} );

			var pieModels = [];
			for(var i=0; i<6; i++) {
				pieModels.push(new THREE.Mesh(pieGeo, pieMat));
			}
/*
			// Traverse board
			for (var iFile = 0; iFile < boardArr.length; iFile++) {

				for (var iColumn = 0; iColumn < boardArr[iFile].length; iColumn++) {

					for (var iLevel = 0; iLevel < boardArr[iFile][iColumn].length; iLevel++) {
						
						var square = boardArr[iFile][iColumn][iLevel]; 

						if (square !== null) {

							// Add indicators
							var ind = new THREE.Mesh(indGeo, indMat);

							ind.position.z = iFile;
							ind.position.x = iColumn;
							ind.position.y = iLevel * 2 + 0.01;

							ind.rotateX(-Math.PI / 2);

							squareInd.add(ind);

							// Add pieces
							// 1:Pawn, 2:Knight, 3:Bishop, 4:Rook, 5:Queen, 6:King
							if (square !== 0) {

								//var piece = pieModels[square-1];
								var piece = new THREE.Mesh(pieGeo, pieMat);
								
								piece.position.z = iFile;
								piece.position.x = iColumn;
								piece.position.y = iLevel * 2;

								//piece.position.y += pieHeight / 2;
								
								pieces.add(piece);

								clickable.push(piece);

							}
						}
					} 
				} 
			} 
/*
			// Add Towers
			for (var iTower = 0; iTower < towerArr.length; iTower++) {

				var tower = new THREE.Mesh(towGeo, towMat);
				
				console.log("iTower: " + iTower + ", tower: " + towerArr[iTower]);
				tower.position.x = towerPos[ towerArr[iTower] - 1].x;
				tower.position.y = towerPos[ towerArr[iTower]  - 1].y;
				tower.position.z = towerPos[ towerArr[iTower]  - 1].z;

				towers.add(tower);

			}
*/
			board.add(towers);

			// Center board on origin
			board.position.x -= 4.5;
			board.position.y -= 4;
			board.position.z -= 2.5;

			scene.add(board);

			function onDocumentMouseMove(event) { 
				event.preventDefault();
				console.log("MouseMove");

				mouseMain.x = (event.clientX /renderer.domElement.clientWidth) * 2 -1;
				mouseMain.y = -(event.clientY /renderer.domElement.clientHeight) * 2 +1;

			}

			renderer.domElement.addEventListener('mousemove', onDocumentMouseMove);


			var selected = null;

			function onDocumentMouseDown(event) {

				event.preventDefault();
				console.log("MouseDown");

				if (selected != null) {
					selected.parent.visible = true;
					selected = null;
					console.log("Make visible");
				}

				raycaster.setFromCamera(mouseMain, camera);
				var intersects = raycaster.intersectObjects(selectable, true);
				if (intersects.length > 0) {
					selected = intersects[0].object;
					selected.parent.visible = false;
					selectable.splice(selectable.indexOf(selected.parent), 1); // NOT FOUND REMOVES LAST ELEMENT

					console.log("Selected " + selected.parent.name);
					console.log(selectable);
				}
				
			}

			renderer.domElement.addEventListener('mousedown', onDocumentMouseDown);


			// Window Resizing
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

			}

			window.addEventListener('resize', onWindowResize, false);


			// Animation loop
			function animate() {

				requestAnimationFrame(animate);
				renderer.render(scene, camera);

			}

			animate();

		</script>
	</body>

<html>
